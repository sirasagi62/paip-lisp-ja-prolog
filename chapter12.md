# 第12章
## ロジックプログラムのコンパイル

[第 11 章](chapter11.md) の最後では、論理変数の新しい、より効率的な表現が導入されました。
この表現を組み込んだ Prolog インタープリターの新しいバージョンを構築するのが合理的でしょう。
しかし、[第 9 章](chapter9.md) では、コンパイラはインタープリタよりも高速に実行され、構築もそれほど難しくないことを学びました。
したがって、この章では、Prolog から Lisp に変換する Prolog コンパイラを紹介します。

それぞれのProlog 述語は Lisp 関数に変換され、異なる数の引数で呼び出される述語は異なる述語とするという規則を採用します。
シンボル `p` が 1 つまたは 2 つの引数で呼び出される場合、2 つの述語を実装するには 2 つの Lisp 関数が必要になります。
Prolog の伝統に従い、これらは `p/1` および `p/2` と呼ばれます。

次のステップは、生成された Lisp コードがどのようになるか決定することです。
各節のheadを引数に対して単一化する必要があり、単一化が成功した場合は、bodyの述語を呼び出す必要があります。
難しいのは、選択ポイントを覚えておかなければならないことです。
最初の節の述語の呼び出しが失敗した場合は、2 番目の節に戻って再試行できる必要があります。

これは、すべての述語に追加の引数として *成功継続* を渡すことによって実行できます。
この継続は、未解決のまま残っている目標、つまり「証明」の「その他の目標」の議論を表します。
述語内の各節について、節内のすべての目標が成功した場合、成功継続を呼び出す必要があります。
目標が達成できなかった場合、特別なことは何もせず、次の節に進むだけです。
1 つ複雑な点があります。失敗した後、`unify!` によって行われたバインドをすべて元に戻す必要があります。
例を考えてみましょう。次の節

```lisp
(<- (likes Robin cats))
(<- (likes Sandy ?x) (likes ?x cats))
(<- (likes Kim ?x) (likes ?x Lee) (likes ?x Kim))
```

は次のようにコンパイルできます。

```lisp
(defun likes/2 (?arg1 ?arg2 cont)
 ;; First clause:
 (if (and (unify! ?arg1 'Robin) (unify! ?arg2 'cats))
   (funcall cont))
 (undo-bindings)
 ;; Second clause:
 (if (unify! ?argl 'Sandy)
   (likes/2 ?arg2 'cats cont))
 (undo-bindings)
 ;; Third clause:
 (if (unify! ?argl 'Kim)
   (likes/2 ?arg2 'Lee
     #'(lambda () (likes/2 ?arg2 'Kim cont))))))
```

最初の節では、2 つの引数をチェックし、単一化が成功した場合は、最初の節にbodyがないため、継続を直接呼び出します。
2 番目の節では、`likes/2` が再帰的に呼び出され、`?arg2` が `cats` を好きかどうかを確認します。
これが成功すると、元の目標は成功し、継続 `cont` が呼び出されます。
3 番目の節では、`likes/2` を再度再帰的に呼び出す必要があります。今回は、`?arg2` が `Lee` を好きかどうかを確認するように要求します。
このチェックが成功すると、継続が呼び出されます。
この場合、継続には `likes/2` への別の呼び出しが含まれ、`?arg2` が `Kim` を好きかどうかを確認します。
これが成功すると、最終的に元の継続である `cont` が呼び出されます。

Prolog インタープリタでは、保留中の目標のリストである`other-goals`を節のbodyの目標に追加する必要があったことを思い出してください。
コンパイラでは、`append` を実行する必要はありません。代わりに、継続 cont が他の目標を表し、節のbodyは関数への明示的な呼び出しによって表されます。

前述の `likes/2` のコードでは、不要な `unify!` の呼び出しがいくつか削除されていることに注意してください。
最も明白な実装では、引数ごとに `unify!` を 1 回呼び出します。
したがって、2 番目の節のコードは次のようになります。

```lisp
(if (and (unify! ?argl 'Sandy) (unify! ?arg2 ?x))
 (likes/2 ?x 'cats cont))
```

ここで、変数 `?x` に適切な let バインディングが必要になります。

## 12.1 Prologコンパイラ

このセクションでは、[図12.1](#f0010)にまとめられたコンパイラを紹介します。
最上位レベルには関数 `prolog-compile` があり、これはシンボルを受け取り、そのシンボルに対して定義された節を調べ、節をアリティ別にグループ化します。
各シンボル/アリティは、`compile-predicate` によって個別の Lisp 関数にコンパイルされます。

| 関数 | 説明 |
|----------------------------|-------------------------------------------------------------------|
| | **トップレベル関数** |
| `?-` | クエリを作成しますが、まずすべてをコンパイルします。 |
| | **特殊変数** |
| `*trail*` | これまでに作成されたすべてのバインディングのリスト。 |
| | **主な関数** |
| `top-level-prove` | 最初にすべてをコンパイルする新バージョン。 |
| `run-prolog` | すべてをコンパイルし、Prolog 関数を呼び出します。 |
| `prolog-compile-symbols` | Prolog シンボルのリストをコンパイルします。 |
| `prolog-compile` | シンボルをコンパイルし、各引数ごとに個別の関数を作成します。 |
| `compile-predicate` | 指定されたシンボル/アリティのすべての節をコンパイルします。 |
| `compile-clause` | headを変換して、結果のbodyをコンパイルします。 |
| `compile-body` | 節のbodyをコンパイルします。 |
| `compile-call` | Prolog 述語への呼び出しをコンパイルします。 |
| `compile-arg` | bodyの目標への引数のコードを生成します。 |
| `compile-unify` | var とterm が単一化されているかどうかをテストするコードを返します。 |
| | **補助関数** |
| `clauses-with-arity` | headが指定されたアリティを持つすべての節を返します。 |
| `relation-arity` | リレーションに対する引数の数。 |
| `args` | 関係の引数。 |
| `make-parameters` | パラメータのリストを作成します。 |
| `make-predicate` | 名前/アリティ形式のシンボルを構築します。 |
| `make-=` | 単一化関係を構築します。 |
| `def-prolog-compiler-macro` | Prolog のコンパイラ マクロを定義します。 |
| `prolog-compiler-macro` | Prolog 述語のコンパイラ マクロを取得します。 |
| `has-variable-p` | 式 `x` のどこかに変数があるかどうか? |
| `proper-listp` | `x` は適切な (ドットなしの) リストかどうか? |
| `maybe-add-undo-bindings` | 元に戻す必要があるバインディングをすべて元に戻します。 |
| `bind-unbound-vars` | 必要に応じて `let` を追加します。 |
| `make-anonymous` | 一度だけ使用される変数を `?` に置き換えます。 |
| `anonymous-variables-in` | 匿名変数のリスト。 |
| `compile-if` | IF フォームをコンパイルします。`else` 部分は使用できません。 |
| `compile-unify-variable` | `var` の単一化をコンパイルします。 |
| `bind-variables-in` | `exp` 内のすべての変数をそれら自身にバインドします。 |
| `follow-binding` | バインディングに従って `var` の最終的なバインディングを取得します。 |
| `bind-new-variables` | バインドされていない変数を含めるようにバインドを拡張します。 |
| `ignore` | 何もしない - 引数を無視します。 |
| | **以前に定義された関数** |
| `unify!` | 破壊的単一化 (セクション 11.6 を参照) |
| `undo-bindings!` | トレイルを使用してバックトラックし、バインドを元に戻します。 |
| `binding-val` | var/val バインディングの値部分を選択します。 |
| `symbol` | インターンされたシンボルを作成または検索します。 |
| `new-symbol` | 新しいインターンされていないシンボルを作成します。 |
| `find-anywhere` | アイテムがツリー内のどこかに出現するかどうか? |

図12.1: Prologコンパイラの用語集

```lisp
(defun prolog-compile (symbol &optional
                       (clauses (get-clauses symbol)))
  "Compile a symbol; make a separate function for each arity."
  (unless (null clauses)
    (let ((arity (relation-arity (clause-head (first clauses)))))
      ;; Compile the clauses with this arity
      (compile-predicate
        symbol arity (clauses-with-arity clauses #'= arity))
      ;; Compile all the clauses with any other arity
      (prolog-compile
        symbol (clauses-with-arity clauses #'/= arity)))))
```

ここには 3 つのユーティリティ関数が含まれています。

```lisp
(defun clauses-with-arity (clauses test arity)
  "Return all clauses whose head has given arity."
  (find-all arity clauses
            :key #'(lambda (clause)
                     (relation-arity (clause-head clause)))
            :test test))

(defun relation-arity (relation)
  "The number of arguments to a relation.
  Example: (relation-arity '(p a b c)) => 3"
  (length (args relation)))

(defun args (x) "The arguments of a relation" (rest x))
```

次のステップは、固定の引数を持つ特定の述語の節を Lisp 関数にコンパイルすることです。
今のところ、各節を個別にコンパイルし、適切なパラメータ リストを使用して `lambda` でラップすることによって実行されます。

```lisp
(defun compile-predicate (symbol arity clauses)
  "Compile all the clauses for a given symbol/arity
  into a single LISP function."
  (let ((predicate (make-predicate symbol arity))
        (parameters (make-parameters arity)))
    (compile
     (eval
      `(defun ,predicate (,@parameters cont)
            .,(mapcar #'(lambda (clause)
                        (compile-clause parameters clause 'cont))
              clauses))))))

(defun make-parameters (arity)
  "Return the list (?arg1 ?arg2 ... ?arg-arity)"
  (loop for i from 1 to arity
        collect (new-symbol '?arg i)))

(defun make-predicate (symbol arity)
  "Return the symbol: symbol/arity"
  (symbol symbol '/ arity))
```

さて、ここからが難しい部分です。実際に節のコードを生成する必要があります。
ここでも、1 つの節に必要なコードの例を示します。
まず、次の簡単なコードをターゲットとして設定します。

```lisp
(<- (likes Kim ?x) (likes ?x Lee) (likes ?x Kim))
(defun likes/2 (?arg1 ?arg2 cont)
 ...
 (if (and (unify! ?argl 'Kim) (unify! ?arg2 ?x)
   (likes/2 ?arg2 'Lee
      #'(lambda () (likes/2 ?x 'Kim))))
...)
```

ただし、改善されたコードへのアップグレードの可能性も検討しています。

```lisp
(defun likes/2 (?arg1 ?arg2 cont)
 ...
 (if (unify! ?arg1 'Kim)
   (likes/2 ?arg2 'Lee
      #'(lambda () (likes/2 ?arg2 'Kim))))
...)
```

1 つのアプローチとしては、`compile-head` と `compile-body` という 2 つの関数を記述し、それらをコードに結合することです (if *head body*)。
このアプローチでは、以前のコードを簡単に生成できます。
しかし、少し先のことを考えてみましょう。最終的に改善されたコードを生成したい場合は、headとbodyの間で何らかの通信が必要になります。
headについては`?arg2` と `?x` の単一化をコンパイルしないことを決定しましたため、bodyについては `?arg2` を `?x` に置き換える必要があることを認識しなければなりません。
つまり、`compile-head` 関数は概念的に、headのコードとbodyで実行する置換の指示という2 つの値を返すということです。
これは複数の値を明示的に操作することで処理できますが、複雑に思えます。

別の方法としては、`compile-head` を削除して `compile-body` のみを記述する方法があります。
これは、実際にその節に対してソースコード変換を実行する場合に可能になります。
この節を次のように扱う代わりに、

```lisp
(<- (likes Kim ?x)
  (likes ?x Lee) (likes ?x Kim))
```

これを同等のものに変形します:

```lisp
(<- (likes ?arg1 ?arg2)
  (= ?arg1 Kim) (= ?arg2 ?x) (likes ?x Lee) (likes ?x Kim))
```

これで、節の先頭の引数が関数 `likes/2` の引数と一致するため、先頭のコードを生成する必要はありません。
これにより、`compile-head` が削除されて単純になり、さらに別の理由でも分解がより適切になります。`compile-head` に最適化を追加する代わりに、`=` を処理する `compile-body` のコードに最適化を追加します。
こうすることで、ソースコード変換によって導入された呼び出しに加えて、ユーザーが `=` に対して行う呼び出しを最適化できます。

概要を把握するために、関数の呼び出しシーケンスは次のようになります。

「``lisp」
プロローグコンパイル
  コンパイル述語
    コンパイル節
      コンパイルbody
        コンパイル呼び出し
        コンパイル引数
        コンパイル-単一化
            コンパイル引数
「」

各関数は、1 レベルインデントされたその下の関数を呼び出します。
最初の 2 つの関数はすでに定義されています。
これが `compile-clause` の最初のバージョンです。

「``lisp」
(defun コンパイル節 (parms 節 cont)
  「頭部を変形し、結果として得られた体をコンパイルします。」
  (コンパイルbody
    (未調整
      (mapcar #'make-= parms (args (節head節)))
      (節body節))
    続き）

(defun make-= (xy) `(= ,x ,y))
「」

作業の大部分は `compile-body` で行われますが、これは少し複雑です。
ケースは3つあります。
bodyがない場合は、継続を呼び出すだけです。
bodyが `=` の呼び出しで始まる場合は、 `unify!` の呼び出しをコンパイルします。
それ以外の場合は、適切な継続を渡して関数の呼び出しをコンパイルします。

しかし、この時点で先を見据えて考える価値はあります。
今 `=` を特別に扱いたいのであれば、おそらく後で他の目標も特別に扱いたくなるでしょう。
したがって、`=` を明示的にチェックする代わりに、データ駆動型のディスパッチを実行して、`prolog-compiler-macro` プロパティがアタッチされている述語を探します。
Lisp コンパイラ マクロと同様に、マクロは目標の処理を拒否できます。
`:pass` を返すことはマクロがそれを処理しないことを決定したことを意味するという規則を採用し、したがって通常のゴールとしてコンパイルする必要があります。

「``lisp」
(defun compile-body (本文続き)
  「節のbodyをコンパイルします。」
  (if (本文がnullの場合)
      `(ファンコール、アカウント)
      (let* ((目標 (最初のbody))
             (マクロ (プロローグコンパイラマクロ (述語目標)))
             (マクロ値 (マクロの場合
                            (funcall マクロ目標 (残りのbody) 続き))))
        (if (and マクロ (not (eq マクロ値 :pass)))
            マクロ値
            （コンパイル呼び出し
               (述語作成 (述語目標)
                               （関係性目標）
               (mapcar #'(lambda (arg) (compile-arg arg))
                       (引数の目標))
               (if (null (残りのbody))
                   続き
                   `#'(ラムダ()
                      、(コンパイルbody (残りのbody) 続き))))))))

(defun compile-call (述語引数 cont)
  「プロローグ述語への呼び出しをコンパイルします。」
  `(,述語,@引数,続き))

(defun プロローグコンパイラマクロ (名前)
  「Prolog 述語のコンパイラ マクロを取得します。」
  ;; NAME は生の名前であり、名前/アリティではないことに注意してください
  (名前 'prolog-compiler-macro) を取得します)

(defmacro def-prolog-compiler-macro (name arglist &body body)
  「Prolog のコンパイラ マクロを定義します。」
  `(setf (get ',name 'prolog-compiler-macro)
         #'(lambda ,引数リスト .,body)))

(def-prolog-compiler-macro = (目標bodyの続き)
  (let ((args (args 目標)))
    (if (/= (長さ引数) 2)
        ：合格
        `(if ,(compile-unify (最初の引数) (2番目の引数))
             、(コンパイルbody body続き)))))

(defun コンパイル-unify (xy)
  「var と term が単一化されているかどうかをテストするコードを返します。」
  `(unify! ,(コンパイル引数 x) ,(コンパイル引数 y)))
「」

残っているのは、body内の目標への引数をコンパイルする関数である `compile-arg` だけです。
以下の `q` の引数へのコンパイルに示すように、考慮すべきケースは 3 つあります。

| []() | |
|----------------------------|----------------- ------------|
| `1 (<- (p ?x) (q ?x))` | `(q/1 ?x 継続)` |
| `2 (<- (p ?x) (q (fab)))` | `(q/1 '(fab) cont)` |
| `3 (<- (p ?x) (q (f ?xb)))` | `(q/1 (リスト 'f ?x 'b) 続き)` |

ケース 1 の場合、引数は変数であり、そのままコンパイルされます。
ケース 2 では、引数は引用符で囲まれた式にコンパイルされる定数式 (変数のない式) です。
ケース 3 では、引数に変数が含まれているため、式を構築するコードを生成する必要があります。
ケース 3 は、実際には以下のリストで 2 つに分割されています。1 つは `list` の呼び出しにコンパイルされ、もう 1 つは `cons` の呼び出しにコンパイルされます。
目標 `(q (f ?xb))` には関数 `f` の呼び出しは含まれないことを覚えておくことが重要です。
むしろ、これは `(f ?xb)` という用語を含み、これは 3 つの要素のリストにすぎません。

「``lisp」
(デフォルトのコンパイル引数(arg)
  「本文の目標に対する引数のコードを生成します。」
  (cond ((変数-p 引数) 引数)
        (((変数 p 引数がない)) `',arg)
        ((適切なリストp引数)
         `(リスト .,(mapcar #'コンパイル引数 arg)))
        (t `(cons ,(compile-arg (最初の引数))
                  ,(コンパイル引数 (残りの引数))))))

(defun has-variable-p(x)
  「式 x のどこかに変数はありますか?」
  (どこでも検索 #'変数p x))

(defun 適切なリスト (x)
  「x は適切な (ドットなしの) リストですか?」
  （または（null x）
      (そして (consp x) (proper-listp (rest x)))))
「」

どのように動作するか見てみましょう。
以下の条項を検討します。

「``lisp」
（<- （ロビン猫が好き））
(<- (サンディが好き?x) (猫が好き?x))
(<- (キムが好き?x) (リーが好き?x) (キムが好き?x))
(<- (メンバー ?item (?item . ?rest)))
(<- (メンバー ?item (?x . ?rest)) (メンバー ?item ?rest))
「」

`prolog-compile` の結果は次のとおりです:

「``lisp」
(DEFUN いいね/2 (?ARG1 ?ARG2 継続)
 (IF (UNIFY! ?ARG1 'ROBIN)
  (IF (UNIFY! ?ARG2 'CATS)
   (ファンコールアカウント)))
 (IF (UNIFY! ?ARG1 'SANDY)
  (IF (UNIFY! ?ARG2 ?X)
   (いいね/2 ?X 'CATS CONT)))
 (IF (UNIFY! ?ARG1 'KIM)
  (IF (UNIFY! ?ARG2 ?X)
   (いいね/2 ?X 'LEE (LAMBDA ()
      (いいね/2 ?X 'KIM CONT))))))
(DEFUN メンバー/2(?ARG1 ?ARG2 継続)
 (IF (UNIFY! ?ARG1 ?ITEM)
  (IF (UNIFY! ?ARG2 (CONS ?ITEM ?REST))
   (ファンコールアカウント)))
 (IF (UNIFY! ?ARG1 ?ITEM)
  (IF (UNIFY! ?ARG2 (CONS ?X ?REST))
   (メンバー/2 ?アイテム ?残り 続き))))
「」

## 12.2 コンパイラのエラーを修正する

このバージョンのコンパイラにはいくつか問題があります。

* `unify!` を呼び出すたびにバインディングを元に戻すのを忘れました。

* 前に定義した `undo-bindings!` の定義では、引数として `*trail*` 配列のインデックスが必要です。
したがって、各関数に入るときに、トレイルの現在の最上部を保存する必要があります。

* `?x` などのローカル変数は導入されずに使用されました。
それらは新しい変数にバインドされる必要があります。

バインディングを元に戻すのは簡単です。`compile-predicate` に 1 行追加して、関数 `maybe-add-undo-bindings` を呼び出すだけです。
この関数は、失敗するたびに `undo-bindings!` の呼び出しを挿入します。
節が 1 つしかない場合は、呼び出しシーケンスの上位にある述語が失敗したときに元に戻すため、元に戻す必要はありません。
複数の節がある場合、関数は関数body全体を let でラップし、トレイルのフィル ポインターの初期値をキャプチャします。これにより、バインディングを適切なポイントまで元に戻すことができます。
同様に、コンパイルされた各節を `bind-unbound-vars` の呼び出しでラップすることで、バインドされていない変数の問題を処理できます。

「``lisp」
(defun compile-predicate (シンボル arity 節)
  「指定されたシンボル/アリティのすべての節をコンパイルする
  単一の LISP 関数に変換します。"
  (let ((述語 (make-述語 シンボル アリティ))
        (パラメータ (make-parameters arity)))
    （コンパイル
     (評価
      `(defun ,述語 (,@パラメータ続き)
  .,(多分、元に戻すバインディングを追加します;***
     (mapcar #'(lambda (節)
           (コンパイル節パラメータ節 'cont))
      節)))))))

(defun コンパイル節 (parms 節 cont)
  「頭部を変形し、結果として得られた体をコンパイルします。」
  (バインドされていない変数;***
    パーマ ;***
    (コンパイルbody
      (未調整
        (mapcar #'make-= parms (args (節head節)))
        (節body節))
      続き）））

(defun maybe-add-undo-bindings (compiled-exps)
  「解除する必要があるバインドをすべて解除します。
  もしあれば、出発前に道筋をはっきりさせてください。」
  (if (長さ=1 コンパイル済み式)
      コンパイルされた式
      `((let ((古いトレイル (フィルポインタ *トレイル*)))
          、(最初にコンパイルされた式)
          ,@(ループ for exp in (rest コンパイル済み exps)
                  collect '(undo-bindings! 古いトレイル)
                  経験値を集める)))))

(defun bind-unbound-vars (パラメータ exp)
  「expに変数がある場合（パラメータ以外）
  次に、それらを新しい変数にバインドします。"
  (let ((exp-vars (set-difference (variables-in exp)
                                  パラメータ)))
    （exp-varsの場合
        `(let ,(mapcar #'(lambda (var) `(,var (?)))
                       経験値-誰のもの)
           ,exp)
        exp)))
「」

これらの改善により、`likes` と `member` のコードは次のようになります。

「``lisp」
(DEFUN いいね/2 (?ARG1 ?ARG2 継続)
 (LET ((OLD-TRAIL (FILL-POINTER *TRAIL*)))
  (IF (UNIFY! ?ARG1 'ROBIN)
   (IF (UNIFY! ?ARG2 'CATS)
      (ファンコールアカウント)))
  (バインドを解除! オールドトレイル)
  (LET ((?X (?)))
   (IF (UNIFY! ?ARG1 'SANDY)
    (IF (UNIFY! ?ARG2 ?X)
      (いいね/2 ?X 'CATS CONT))))
  (バインドを解除! オールドトレイル)
  (LET ((?X (?)))
   (IF (UNIFY! ?ARG1 'KIM)
    (IF (UNIFY! ?ARG2 ?X)
      (いいね/2 ?X 'LEE (LAMBDA ()
          (いいね/2 ?X 'KIM CONT))))))))
(DEFUN メンバー/2(?ARG1 ?ARG2 継続)
 (LET ((OLD-TRAIL (FILL-POINTER *TRAIL*)))
  (LET ((?項目 (?))
      （？休む （？）））
   (IF (UNIFY! ?ARG1 ?ITEM)
      (IF (UNIFY! ?ARG2 (CONS ?ITEM ?REST))
            (ファンコールアカウント))))
  (バインドを解除! オールドトレイル)
  (LET ((?X (?))
      （？ アイテム （？））
      （？休む （？）））
  (IF (UNIFY! ?ARG1 ?ITEM)
   (IF (UNIFY! ?ARG2 (CONS ?X ?REST))
            (メンバー/2 ?アイテム ?残り 続き))))))
「」

## 12.3 コンパイラの改善

これはかなり良いですが、まだ改善の余地があります。
小さな改善点の 1 つは、不要な変数を削除することです。
たとえば、`member` の最初の節の `?rest` と 2 番目の節の `?x` は、新しい変数 (`(?)` 呼び出しの結果) にバインドされ、一度だけ使用されます。
生成されたコードは、変数にバインドしてからその変数を参照するのではなく、単に `(?)` をインラインに配置することで、もう少し簡潔にすることができます。
この変更には 2 つの部分があります。`compile-arg` を更新して匿名変数をインラインでコンパイルすることと、`<-` マクロを変更して、節内に 1 回だけ出現するすべての変数を匿名変数に変換することです。

「``lisp」
(defmacro <- (&rest 節)
  「データベースに節を追加します。」
  `(add-clause ',(make-anonymous 節)))

(デフォルトのコンパイル引数(arg)
  「本文の目標に対する引数のコードを生成します。」
  (cond ((変数-p 引数) 引数)
        (((変数 p 引数がない)) `',arg)
        ((適切なリストp引数)
         `(リスト .,(mapcar #'コンパイル引数 arg)))
        (t `(cons ,(compile-arg (最初の引数))
                  ,(コンパイル引数 (残りの引数))))))

(defun make-anonymous (exp &optional
                       (anon-vars (exp 内の匿名変数)))
  「一度だけ使用される変数を ? に置き換えます。」
  (条件 ((consp exp)
         (再利用コンス (匿名化 (最初の式) 匿名変数)
                     (匿名化 (残り exp) 匿名変数)
                     exp))
        ((メンバー exp anon-vars) '?)
        (t exp)))
「」

匿名変数を見つけるのは難しいです。
次の関数は、1 回だけ使用された変数と 2 回以上使用された変数の 2 つのリストを保持します。
次に、ローカル関数 `walk` を使用してツリーを走査し、各コンス セルのコンポーネントを再帰的に考慮し、各変数に遭遇するたびに 2 つのリストを更新します。
このローカル関数の使用法は、[ページ 428](#p428) の [演習 12.23](#p4625) で説明されている代替案と同様に覚えておく必要があります。

「``lisp」
(匿名変数を定義 (ツリー)
  「ツリー内で一度だけ出現するすべての変数のリストを返します。」
  (let ((seen-once nil)
            (seen-more nil))
    (ラベル ((ウォーク (x)
            （条件
                ((変数-p x)
                    (条件 ((メンバー x 一度だけ見る)
                              (setf seen-once (delete x seen-once))
                              (押す x 見る-さらに))
                        ((メンバー x 見た数-さらに) なし)
                        (t (プッシュ x 1 回表示))))
                ((x を仮定)
                    (歩く (最初の x))
                    (歩く (休憩 x))))))
      （木を歩く）
      一度見た)))
「」

これで、`member` は次のようにコンパイルされます。

「``lisp」
(DEFUN メンバー/2(?ARG1 ?ARG2 継続)
 (LET ((OLD-TRAIL (FILL-POINTER *TRAIL*)))
  (LET ((?項目 (?)))
   (IF (UNIFY! ?ARG1 ?ITEM)
    (IF (UNIFY! ?ARG2 (CONS ?ITEM (?)))
        (ファンコールアカウント))))
  (バインドを解除! オールドトレイル)
  (LET ((?項目 (?))
    （？休む （？）））
   (IF (UNIFY! ?ARG1 ?ITEM)
    (IF (UNIFY! ?ARG2 (CONS (?) ?REST))
      (メンバー/2 ?アイテム ?残り 続き))))))
「」

## 12.4 統一コンパイルの改善

ここで、`compile-unify` の改善について説明します。
たとえば、`member` の最初の節のように、`unify!` への特定の呼び出しを削除したいことを思い出してください。

「``lisp」
(<- (メンバー ?item (?item . ?rest)))
「」

コンパイルすると次のようになります:

「``lisp」
(LET ((?項目 (?)))
 (IF (UNIFY! ?ARG1 ?ITEM)
  (IF (UNIFY! ?ARG2 (CONS ?ITEM (?)))
    (ファンコールアカウント))))
「」

より効率的にコンパイルできる場合:

「``lisp」
(IF (UNIFY! ?ARG2 (CONS ?ARG1 (?)))
  (ファンコールアカウント))
「」

1 つの目標で統一を解除すると、後で他の目標にも影響が出るため、統一された表現を追跡する必要があります。
デザインの選択肢があります。
`compile-unify` はグローバル状態変数を変更することも、複数の値を返すこともできます。
グローバル変数は扱いにくいという理由で、2 番目の選択肢を採用します。`compile-unify` はバインディング リストを追加の引数として受け取り、実際のコードと更新されたバインディング リストの 2 つの値を返します。
これらの複数の値を処理するには、他の関連関数を変更する必要があると考えられます。

`compile-unify` が例の節で最初に呼び出されると、`?arg1` と `?item` を単一化するように求められます。
コードを返さないようにします (より正確には、自明な真のテスト `t`)。
2 番目の値については、`?item` が `?arg1` にバインドされた新しいバインディング リストを返す必要があります。
このバインディングは、後続のコードで `?item` を `?arg1` に置き換えるために使用されます。

`?item` を `?arg1` にバインドするのではなく、その逆を行うことをどのようにして知るのでしょうか?
`?arg1` はすでに何か、つまり `member` に渡された値にバインドされているからです。この値が何であるかはわかりませんが、無視することはできません。
したがって、初期バインディング リストでは、パラメーターが何かにバインドされていることを示す必要があります。
単純な規則としては、パラメータをそれ自体にバインドすることです。
したがって、初期のバインディング リストは次のようになります。

「``lisp」
((?arg1 .?arg1) (?arg2 . ?arg2))
「」

前の章 ([ページ 354](chapter11.md#p354)) で、変数をそれ自身にバインドすると問題が発生する可能性があることを説明したので、注意が必要です。

パラメータに対する新しい変数の単一化を排除する以外にも、改善できる点はたくさんあります。
たとえば、定数のみを含む単一化はコンパイル時に実行できます。
呼び出し `(= (fa) (fa ))` は常に成功しますが、 `(= 3 4)` は常に失敗します。
さらに、2 つのコンス セルの単一化は、コンパイル時にコンポーネントに分割できます。`(= (f ?x) (fa))` は `(= ?xa)` と `(= ff)` に簡略化され、後者は簡単に成功します。
コンパイル時にいくつかの発生チェックを行うこともできます: `(= ?x (f ?x))` は失敗するはずです。

次の表は、これらの改善点と、バインドされた `(?arg1)` またはバインドされていない `(?x)` 変数を別の式に対して単一化する場合の内訳を示しています。
最初の列は単一化呼び出し、2 番目は生成されたコード、3 番目は呼び出しの結果として追加されるバインディングです。

| | 統一 | コード | バインディング |
|------|---------------------|----------- -----|----------|
| 1 | `(= 3 3)` | `t` | `-` |
| 2 | `(= 3 4)` | `nil` | `-` |
| 3 | `(= (f ?x) (?p 3))` | `t` | `(?x . 3) (?p . f)` |
| 4 | `(= ?arg1 ?y)` | `t` | `(?y . ?arg1)` |
| 5 | `(= ?arg1 ?arg2)` | `(unify! ?arg1 ?arg2)` | `(?arg1 . ?arg2)` |
| 6 | `(= ?arg1 3)` | `(unify! ?arg1 3)` | `(?arg1 . 3)` |
| 7 | `(= ?arg1 (f ? y))` | `(統一! ?arg1 . . . )` | `(?y . ?y)` |
| 8 | `(= ?x ?y)` | `t` | `(?y . ?y)` |
| 9 | `(= ?x 3)` | `t` | `(?x . 3)` |
| 10 | `(= ?x (f ? y))` | `(unify! ?x . . . )` | `(?y . ?y)` |
| 11 | `(= ?x (f ? x))` | `nil` | `-` |
| 12 | `(= ?x ?)` | `t` | `-` |

この表から、`compile-unify` の新しいバージョンを作成できます。
最初の部分はかなり簡単です。
これは、この表の最初の 3 つのケースを処理し、他のケースでは最初の引数として変数を使用して `compile-unify-variable` が呼び出されるようにします。

「``lisp」
(defun compile-unify (xy バインディング)
  「2つの値を返す：xとyが単一かどうかをテストするコード、
  そして新しいバインディング リスト。"
  （条件
    ;; 定数とconsを単一化する: ; ケース
    ((not (or (has-variable-p x) (has-variable-p y))) ; 1,2
     (値 (等しい xy) バインディング))
    ((および (consp x) (consp y)) ; 3
     (複数値バインド (コード1 バインディング1)
         (compile-unify (最初の x) (最初の y) バインディング)
       (複数値バインド (コード2 バインディング2)
           (コンパイル-単一化 (残り x) (残り y) バインディング1)
         (値 (コンパイル時コード1 コード2) バインディング2))))
    ;; ここで x または y は変数です。正しいものを選択してください。
    ((variable-p x) (compile-unify-variable xy バインディング))
    (t (compile-unify-variable yx バインディング))))

(defun コンパイル-if (pred then-part)
  「Lisp IF フォームをコンパイルします。else パートは許可されません。」
  （ケース予測
    ((t) 当時の部分)
    ((なし) なし)
    (それ以外の場合 `(if,pred,then-part))))
「」

次の関数 `compile-unify-variable` は、これまで見た中で最も複雑なものの 1 つです。
各引数について、バインディング (ローカル変数 `xb` および `yb`) があるかどうかを確認し、バインディングを使用して各引数の値 (`x1` および `y1`) を取得します。
バインドされていない変数または自身にバインドされている変数のいずれの場合も、`x` は `x1` に等しくなります (`y` と `y1` についても同様です)。
どちらかの値のペアが等しくない場合は、新しい値 (`x1` または `y1`) を使用する必要があります。コメント化された deref 節がそれを実行します。
その後は、ケースを一つずつ確認していきます。
前の表から少し順序を変える方が簡単であることがわかりましたが、各節には対応する番号がコメントされています。

「``lisp」
(defun compile-unify-variable (xy バインディング)
  「X は変数であり、Y も変数である可能性があります。」
  (let* ((xb (follow-binding x バインディング))
         (x1 (xb (cdr xb) xの場合))
         (yb (if (variable-p y) (follow-binding y bindings)))
         (y1 (もし yb (cdr yb) y)))
    (条件; ケース:
      ((または (eq x '?) (eq y '?)) (値 t バインディング)) ; 12
      ((not (and (equal x x1) (equal y y1))) ; 参照解除
       (コンパイル-単一化 x1 y1 バインディング))
      ((find-anywhere x1 y1) (値 nil バインディング)) ; 11
      ((定数y1) ; 7,10
       (値 `(unify! ,x1 ,(compile-arg y1 バインディング))
               (bind-variables-in y1 バインディング)))
      ((null xbではない))
       ;; つまり、xは?arg変数です
       (if (and (variable-p y1) (null yb))
           (値 't (バインディングの拡張 y1 x1 バインディング)) ; 4
           (値 `(unify! ,x1 ,(compile-arg y1 バインディング))
                   (バインディング x1 y1 を拡張)))) ; 5,6
      (((null yb)ではない)
       (compile-unify-variable y1 x1 バインディング))
      (t (値 't (バインディング x1 y1 バインディングの拡張)))))) ; 8,9
「」

この機能がどのように動作するかを理解するために少し時間を取ってください。
次に、次の補助機能に進みます。

「``lisp」
(defun bind-variables-in (exp バインディング)
  「exp内のすべての変数を自身にバインドし、それを
  バインディング（すでにバインドされている変数を除く）。"
  (dolist (var (変数-in exp))
    (ただし、(get-binding var バインディング)
      (setf バインディング (extend-bindings var var バインディング))))
  バインディング

(defun フォローバインディング (var バインディング)
  「バインディングに従って var の最終的なバインディングを取得します。」
  (let ((b (get-binding var bindings)))
    (もし (車 b) (cdr b) と等しい)
        b
        （または（follow-binding (cdr b) バインディング）
            b))))
「」

ここで、新しい `compile-unify` をコンパイラの残りの部分に単一化する必要があります。
問題は、新しいバージョンでは追加の引数を取り、追加の値を返すため、それを呼び出すすべての関数を変更する必要があることです。
呼び出しシーケンスをもう一度見てみましょう。

「``lisp」
プロローグコンパイル
  コンパイル述語
    コンパイル節
      コンパイルbody
        コンパイル呼び出し
        コンパイル引数
          コンパイル-単一化
            コンパイル引数
「」

まず、下に向かっていくと、`compile-arg` は適切な値を検索して代入できるように、引数としてバインディング リストを取る必要があることがわかります。
ただし、バインディング リストは変更されないため、1 つの値が返されます。

「``lisp」
(廃止されたコンパイル引数(引数バインディング)
  「本文の目標に対する引数のコードを生成します。」
  (条件 ((等価引数 '?) '(?))
        ((変数-p 引数)
         (let ((binding (get-binding arg bindings)))
           (if (and (not (null バインディング))
                    (not (eq arg (binding-val binding))))
             (compile-arg (binding-val binding) バインディング)
             arg)))
        ((not (find-if-anywhere #'variable-p arg)) `',arg)
        ((適切なリストp引数)
         `(list .,(mapcar #'(lambda (a) (compile-arg a バインディング))
                          arg)))
        (t `(cons ,(compile-arg (最初の引数) バインディング)
                  、(コンパイル引数 (残り引数) バインディング)))))
「」

さて、上に向かって、`compile-body` はバインディング リストを受け取り、それをさまざまな関数に渡す必要があります。

「``lisp」
(defun compile-body (body cont バインディング)
  「節のbodyをコンパイルします。」
  （条件
    ((本文なし)
     `(ファンコール、アカウント))
    ((eq (最初のbody) '!) ;***
     `(progn ,(compile-body (rest body) cont bindings) ;***
             (戻り値、*述語* nil))) ;***
    (t (let* ((目標 (最初のbody))
              (マクロ (プロローグコンパイラマクロ (述語目標)))
              (マクロ値 (マクロの場合
                             (funcallマクロ目標(残りのbody)
                                      contバインディング))))
        (if (and マクロ (not (eq マクロ値 :pass)))
            マクロ値
            `(,(make-predicate (述語目標)
                               （関係性目標）
              ,@(mapcar #'(lambda (arg)
                            (コンパイル引数 引数バインディング))
                        (引数の目標))
              ,(if (null (残りのbody))
                   続き
                   `#'(ラムダ()
                        、(コンパイルbody
                           （残りの本文）続き
                           (bind-new-variables バインディング ゴール))))))))))
「」

関数 `bind-new-variables` は、目標内でまだバインドされていない変数を取得し、それらの変数を自分自身にバインドします。
これは、目標が何であれ、その目標の議論を拘束する可能性があるためです。

「``lisp」
(defun bind-new-variables (バインディング目標)
  「バインドされていない変数を目標に含めるようにバインドを拡張します。」
  (let ((変数 (remove-if #'(lambda (v) (assoc v バインディング))
                              (変数の目標))))
    (nconc (mapcar #'self-cons 変数) バインディング)))

(自己コンス定義 (x) (コンス xx))
「」

バインディング リストを受け入れるために変更する必要がある関数の 1 つは、`=` のコンパイラ マクロです。

「``lisp」
(def-prolog-compiler-macro = (目標bodycontバインディング)
  「= への呼び出しであるゴールをコンパイルします。」
  (let ((args (args 目標)))
    (if (/= (長さ引数) 2)
        :pass ;; この目標の処理を拒否する
        (複数値バインド (コード1 バインディング1)
            (compile-unify (最初の引数) (2 番目の引数) バインディング)
          （コンパイル-if
            コード1
            (コンパイルbodybodyバインディング1))))))
「」

最後のステップは、`compile-clause` を変更して、すべてのパラメータが自身にバインドされたバインディング リストを `compile-body` に渡すことですべてを開始するようにすることです。

「``lisp」
(defun コンパイル節 (parms 節 cont)
  「頭部を変形し、結果として得られた体をコンパイルします。」
  (バインドされていない変数
    パームス
    (コンパイルbody
      (未調整
        (mapcar #'make-= parms (args (節head節)))
        (節body節))
      続き
      (mapcar #'自己コンス パラメータ)))) ;***
「」

ついに、私たちの努力の成果が明らかになりました。

「``lisp」
(DEFUN メンバー/2(?ARG1 ?ARG2 継続)
 (LET ((OLD-TRAIL (FILL-POINTER *TRAIL*)))
  (IF (UNIFY! ?ARG2 (CONS ?ARG1 (?)))
      (ファンコールアカウント))
  (バインドを解除! オールドトレイル)
  (LET ((?REST (?)))
    (IF (UNIFY! ?ARG2 (CONS (?) ?REST))
        (メンバー/2 ?ARG1 ?残り継続)))))
 (DEFUN いいね/2 (?ARG1 ?ARG2 継続)
  (LET ((OLD-TRAIL (FILL-POINTER *TRAIL*)))
    (IF (UNIFY! ?ARG1 'ROBIN)
        (IF (UNIFY! ?ARG2 'CATS)
          (ファンコールアカウント)))
    (バインドを解除! オールドトレイル)
    (IF (UNIFY! ?ARG1 'SANDY)
      (いいね数/2 ?ARG2 'CATS CONT))
    (バインドを解除! オールドトレイル)
    (IF (UNIFY! ?ARG1 'KIM)
      (いいね/2 ?ARG2 'LEE (LAMBDA ()
            (いいね/2 ?ARG2 'KIM CONT))))))
「」

## 12.5 単一化のさらなる改善

`compile-unify` はさらに改善される可能性がありますか?
`unify!` を呼び出すように主張すると、これ以上改善することはできないようです。
ただし、実際には `unify!` をコンパイルすることで改善できます。
これは、Prolog コンパイラーで最も一般的に使用されているモデルである Warren Abstract Machine (WAM) の重要なアイデアです。

4 つのケース (5、6、7、および 10) で `unify!` を呼び出しますが、いずれの場合も最初の引数は変数であり、2 番目の引数については何かがわかっています。
しかし、`unify!` が最初に行うことは、最初の引数が変数であるかどうかを冗長にテストすることです。
汎用関数「unify!」ではなく、より特化した関数を呼び出すことで、不要なテストを排除できます。
次の呼び出しを考えてみましょう:

「``lisp」
(unify! ?arg2 (cons ?arg1 (?)))
「」

`?arg2` がバインドされていない変数の場合、このコードは適切です。
しかし、`?arg2` が定数アトムである場合は、`cons` と `?` がガベージを生成するのを許可せずに、すぐに失敗する必要があります。
テストを次のように変更できます。

「``lisp」
(および (consp-or-variable-p ?arg2)
  (まず統一! ?arg2 ?arg1)
  (unify-rest! ?arg2 (?)))
「」

ここで参照される関数の適切な定義を使用します。
この変更により、実行時間が短縮され、生成されるガベージの量が制限されるはずです。
もちろん、生成されるコードは長くなるため、プログラムがコードをプロセッサに送るのに時間がかかりすぎると、処理速度が低下する可能性があります。

**演習 12.1 [h]** `consp-or-variable-p、unify-first!、`、`unify-rest!` の定義を記述し、コンパイラを変更して、前に概説したようなコードを生成します。
[セクション9.6](chapter9.md#s0035)の[ページ300](chapter9.md#p300)から始まる関数`compile-rule`を確認するとよいでしょう。
この関数は `pat-match` の呼び出しを個別のテストにコンパイルしました。今度は同じことを `unify!` に対して実行します。
いくつかのベンチマークを実行して、変更されたコンパイラを元のバージョンと比較します。

**演習 12.2 [h]** どの変数が逆参照されたかを追跡し、適切な単一化関数 (引数を逆参照する関数、または引数がすでに逆参照されていると想定する関数) を呼び出すことで、さらに効率を上げることができます。
このアプローチを実装します。

**演習 12.3 [m]** `(= (f (g ?x) ?y) (f ?y (?pa))) に対してどのようなコードが生成されますか?` 同じ統一を表すより効率的なコードは何ですか?
このより効率的な結果を得るためにコンパイラを変更するのはどれくらい簡単ですか?

**演習 12.4 [h]** 振り返ってみると、`(?argl . ?argl`) のように変数を自分自身にバインドするのはあまり良い考えではなかったようです。
これにより、バインディングの意味が複雑になり、既存のツールを使用できなくなります。
たとえば、ケース 11 では、`occur-check` は非循環バインディング リストを期待するため、`occur-check` ではなく `find-anywhere` を使用する必要がありました。
しかし、find-anywhere は `occur-check` ほど完全な仕事をしません。
コード、非循環バインディング リスト、および不明な値にバインドされている変数のリストの 3 つの値を返す `compile-unify` バージョンを記述します。

**演習 12.5 [h]** 前の演習の代わりとして、バインディング リストをまったく使用しないこともできます。
代わりに、同値クラスのリスト、つまり各サブリストに単一化された 1 つ以上の要素が含まれるリストのリストを渡すこともできます。
このアプローチでは、初期の同値クラス リストは `((?arg1) (?arg2))` になります。
`?arg1` を `?x` と単一化し、`?arg2` を `?y` と単一化し、`?x` を 4 と単一化すると、リストは ( `(4 ?arg1 ?x) (?arg2 ?y))` になります。
これは、同値クラスの標準メンバー (他のすべてのメンバーの代わりになるメンバー) が最初に来るという規則を前提としています。
このアプローチを実装します。
どのような利点と欠点がありますか?

## 12.6 コンパイラのユーザーインターフェース

コンパイラは Prolog を Lisp に変換できますが、適切な Prolog 関係をコンパイルして適切な Lisp 関数を呼び出すように都合よく調整できない限り、それは役に立ちません。
つまり、コンパイラを `<-` および `?` マクロと単一化する必要があります。
驚くべきことに、これらのマクロを変更する必要はまったくありません。
むしろ、これらのマクロが呼び出す関数を変更します。
新しい節が入力されると、その節の述語がリスト `*uncompiled*` に入力されます。
これは`add-clause:`への1行の追加です。

「``lisp」
(defvar *未コンパイル* nil
  「コンパイルされていない Prolog シンボル」

(defun add-clause (節)
  「headの述語によってインデックス付けされた節をデータベースに追加します。」
  ;; 述語は変数以外のシンボルである必要があります。
  (let ((pred (述語 (節head節))))
    (assert (and (symbolp pred) (not (variable-p pred))))
    (pushnew pred *db-predicates*)
    (pushnew pred *未コンパイル*) ;***
    (setf (get pred '節)
          (nconc (get-clauses pred) (list 節)))
    前に））
「」

クエリが実行されると、`?-` マクロが `top-level-prove` の呼び出しに展開されます。
クエリ内のゴールのリストは、`show-prolog-vars` ゴールとともに、関係 `top-level-query` の唯一の節として追加されます。
次に、そのクエリは、コンパイルされていないリストにある他のクエリとともにコンパイルされます。
最後に、新しくコンパイルされたトップレベルのクエリ関数が呼び出されます。

「``lisp」
(defun トップレベル証明 (目標)
  「ゴールのリストをコンパイルして呼び出すことで証明します。」
  ;; まずトップレベルのクエリを再定義します
  (クリア述語 'トップレベルクエリ)
  (let ((vars (delet '? (変数内の目標))))
    (add-clause `((トップレベルクエリ)
                  、@目標
                  (show-prolog-vars、(mapcar #'シンボル名vars)
                                    、だれの））））
  ;; 実行してみましょう
  (run-prolog 'トップレベルクエリ/0 #'無視)
  (フォーマット t "~&No.")
  (値)

(defun run-prolog (手順の続き)
  「指定された継続を使用して 0 項プロローグ プロシージャを実行します。」
  ;; まず必要なものをコンパイルします
  (プロローグコンパイルシンボル)
  ;; トレイルと新しい変数カウンタをリセットします
  (setf (フィルポインタ *trail*) 0)
  (setf *var-counter* 0)
  ;; 最後にクエリを呼び出します
  (キャッチ'トップレベル証明
    (funcall 手順の続き)))

(defun prolog-compile-symbols (&optional (シンボル *未コンパイル*))
  「Prolog シンボルのリストをコンパイルします。
  デフォルトでは、必要なすべてのシンボルがリストに表示されます。"
  (マップ #'prolog-compile シンボル)
  (setf *未コンパイル* (set-difference *未コンパイル* シンボル)))

(デフォルトは無視 (& 残りの引数)
  (宣言 (引数を無視))
  なし
「」

トップレベルでは、継続して何かを行う必要がないことに注意してください。
任意に、引数を無視するように定義された関数 `ignore` を渡すことを選択しました。
この関数はさまざまな場所で役立ちます。プログラマーによっては、これをインラインで宣言し、ignore 宣言の代わりに `ignore` の呼び出しを使用する人もいます。

「``lisp」
(廃止された第 3 引数(xyz)
  (xyは無視)
  と）
「」

コンパイラの呼び出し規約はインタープリタとは異なるため、プリミティブを再定義する必要があります。
プリミティブ `show-prolog-vars` の古い定義には、目標への引数のリスト、バインディング リスト、保留中の目標のリストの 3 つのパラメーターがありました。
`show-prolog-vars/2` の新しい定義にも 3 つのパラメータがありますが、これは単なる偶然です。
最初の 2 つのパラメーターは、目標に対する 2 つの個別の引数です。変数名のリストと変数値のリストです。
最後のパラメータは継続関数です。
続行するにはその関数を呼び出しますが、失敗する場合は `top-level-prove` で設定されたキャッチ ポイントにスローします。

「``lisp」
(defun show-prolog-vars/2 (var-names vars cont)
  「変数を表示し、ユーザーに確認を促す
  続行するかどうか。続行しない場合は、トップレベルに戻ります。
  (if (null 変数)
      (フォーマット t "~&はい")
      (var-names 内の名前をループする
            というのは誰の仕業だったのか
            (format t "~&~a = ~a" name (deref-exp var))))
  (if (継続-p)
      (ファンコールアカウント)
      ('トップレベルでnilを証明する'をスローします)))

(defun deref-exp (exp)
  「変数を逆参照した EXP と同等のものを構築します。」
  (if (アトム (参照式))
      経験
      （再利用コン
        (deref-exp (最初のexp))
        (deref-exp (rest exp))
        exp)))
「」

これらの定義が配置されていると、`?-` マクロを使用してクエリを実行するだけで、コンパイラを自動的に呼び出すことができます。

**演習 12.6 [m]** `q` を呼び出す述語 `p` を定義し、次に `q` を定義するとします。
Lisp の一部の実装では、`(?- (p ?x))` のようなクエリを実行すると、正しい答えが得られる前に `"function q/1 undefined"` のような警告メッセージが表示されることがあります。
問題は、各関数が個別にコンパイルされるため、関数 `q/1` が後で定義される場合でも、`p/1` のコンパイル中に検出された警告がすぐに出力されることです。
ANSI Common Lisp には、一連のコンパイルが完了するまで警告の出力を遅らせる方法があります。コンパイルをマクロ `with-compilation-unit` でラップします。
実装でこのマクロが提供されない場合でも、別の名前で同じ機能が提供される場合があります。
実装で `with-compilation-unit` がすでに定義されているか、または定義できるかどうかを確認します。

## 12.7 コンパイラのベンチマーク

コンパイルされた Prolog コードは、シマウマ パズルを 17.4 秒で実行します。これは、解釈されたバージョンに比べて 16 倍高速で、速度は 740 LIPS です。

もう一つの一般的なベンチマークは Lisp の `reverse` 関数で、これは `rev` 関係としてコード化できます。

「``lisp」
(<- (rev()()))
(<- (rev (?x . ?a) ?b) (rev ?a ?c) (concat ?c (?x) ?b))

(<- (連結() ?1 ?1)
(<- (連結 (?x . ?a) ?b (?x . ?c)) (連結 ?a ?b ?c))
「」

`rev` は連結を表す関係 `concat` を使用します。
`(concat ?a ?b ?c)` は、`?a` を `?b` に連結すると `?c` になるときに true になります。
この関係に似た名前は、append のようなより手続き的な名前よりも優先されます。
しかし、`rev` は次の Lisp 定義と非常によく似ています。

「``lisp」
(デフォルトの回転 (1)
  (if (null 1)
    ゼロ
    (アプリ (回転 (残り 1 ))
        (リスト (最初の 1)))))

(アプリを定義(xy)
  (if (null x)
    そして
      (cons (最初のx)
        (アプリ (残り x) y))))
「」

どちらのバージョンも非効率的です。
追加のコンシングを行わず、末尾再帰である `reverse` の反復バージョンを記述することは可能です。

「``lisp」
(<- (irev ?l ?r) (irev3 ?l () ?r))
(<- (irev3 (?x . ?l) ?これまでのところ ?r) (irev3 ?l (?x . ?これまでのところ) ?r))
(<- (irev3() ?r ?r))
「」

Prolog の `irev` は次の Lisp プログラムと同等です。

「``lisp」
(defun irev(list)(irev2 list nil))

(廃止された irev2 (これまでのリスト)
  (if (consp リスト)
      (irev2 (残りのリスト) (cons (最初のリスト) ここまで))
      これまでのところ））
「」

次の表は、Prolog と Lisp の両方で、解釈およびコンパイルされた長さ 20 と 100 のリストに対してこれらのルーチンを実行するのにかかる時間 (秒単位) を示しています。
(コンパイルされた Lisp だけが、スタック領域を使い果たすことなく 100 要素のリストで rev を実行できました。) このプログラムの Lisp バージョンはありませんが、シマウマ パズルの時間も含まれています。

| 問題 | Prolog の解釈 | Prolog の補完 | スピードアップ | Lisp の解釈 | Lisp の補完 |
|-----------|----------------|--------------|---- ----------|--------------|----------|
| `シマウマ` | 278.000 | 17.241 | 16 | - | - |
| `rev 20` | 4.24 | .208 | 20 | .241 | .0023 |
| `回転数 100` | - | - | - | - | .0614 |
| `rev 20` | .22 | .010 | 22 | .028 | .0005 |
| `rev 100` | 9.81 | .054 | 181 | .139 | .0014 |

このベンチマークは決定的であるには小さすぎますが、これらの例では、Prolog コンパイラは Prolog インタープリタよりも 16 ～ 181 倍高速で、インタープリタ型 Lisp よりもわずかに高速ですが、コンパイル型 Lisp よりも 17 ～ 90 倍遅いです。
これは、Prolog インタープリタは実用的なプログラミング ツールとして使用できないが、Prolog コンパイラは使用できることを示唆しています。

先に進む前に、Prolog がオプションの引数を自動的に提供することに注目してください。
オプション引数には特別な構文はありませんが、よく使用される規則では、関係に 2 つのバージョン (1 つは *n* 個の引数、もう 1 つは *n* - 1 個) があります。
*n* - 1 の場合の単一の節は、欠落している、つまり「オプション」の引数を提供します。
次の例では、`irev/2` は、省略可能な引数が () である `irev/3` のバージョンと見なすことができます。

「``lisp」
(<- (irev ?l ?r) (irev ?l () ?r))
(<- (irev (?x . ?l ) ?so-far ?r) (irev ?l (?x . ?so-far) ?r))
(<- (irev () ?r ?r))
「」

これは、次の Lisp バージョンとほぼ同等です。

「``lisp」
(defun irev(list &optional(so-far nil))
  (if (consp リスト)
      (irev (残りのリスト) (cons (最初のリスト) これまで))
      これまでのところ））
「」

## 12.8 プリミティブの追加

Lisp コンパイラが入出力や演算などを実行するためにマシン命令を必要とするのと同様に、Prolog システムも特定の基本的なアクションを実行できる必要があります。
Prolog インタープリタの場合、プリミティブは関数シンボルによって実装されました。
インタープリタが節のリストを取得しようとしたときに、代わりに関数を取得した場合は、その関数を呼び出して、現在の関係、現在のバインディング、および満たされていない目標のリストへの引数を渡します。
Prolog コンパイラの場合、継続を最終引数として取るという規則に従い、*symbol/arity* という形式の名前を持つ Lisp 関数を記述するだけで、プリミティブをインストールできます。たとえば、入力と出力を処理する簡単な方法を次に示します。

「``lisp」
(defun read/1 (exp cont)
 (if (unify! exp (read))
   (ファンコールアカウント)))
(defun write/1 (exp cont)
 ((deref-exp exp) と書く:pretty t)
 (ファンコールアカウント))
「」

`(write ?x)` の呼び出しは常に成功するので、継続は常に呼び出されます。
同様に、`(read ?x)` を使用して値を読み取り、それを `?x` と単一化することもできます。
`?x` がバインドされていない場合、これは値を割り当てることと同じです。
ただし、`(read (?x + ?y))` のような呼び出しを行うことも可能で、これは入力が中央に + がある 3 要素のリストである場合にのみ成功します。
どのストリームを使用するかを示す関係として `read/2` と `write/2` を定義するのは簡単な拡張です。
これを便利にするには、パス名を 1 つの引数として受け取り、ストリームをもう 1 つの引数として返す関係として `open/2` を定義する必要があります。
必要に応じて、他のオプションの引数もサポートされます。

プリミティブ `nl` は改行を出力します。

「``lisp」
(defun nl/0 (続き) (terpri) (funcall 続き))
「」

単一化述語「=」に特別なサポートを提供しました。
ただし、`=/2` の単純な定義を使用することで、コンパイラを大幅に簡素化できます。

「``lisp」
(defun =/2 (?arg1 ?arg2 cont)
 (if (unify! ?arg1 ?arg2)
  (ファンコールアカウント)))
「」

実際、コンパイラに次の単一の節を与えると、

`(<- (= ?x ?x))`

`=/2` の定義に対してこのコードが生成されます。
他にも考慮すべき等価述語があります。
述語 `==/2` は Lisp では equal に似ています。
統一は行いませんが、代わりに 2 つの構造がその要素に関して等しいかどうかをテストします。
変数はそれ自身とのみ等しいとみなされます。
実装は次のとおりです。

「``lisp」
(defun =/2 (?arg1 ?arg2 cont)
 「2つの議論は統一されずに等しいのか、
 しかし、逆参照は？そうであれば、成功します。"
 ((参照が等しい?arg1?arg2の場合)
  (ファンコールアカウント)))
(defun deref-equal (xy)
 「2つの議論は統一されずに等しいのか、
 しかし、逆参照では？」
 (または (eql (deref x) (deref y))
  （そして（xを前提とする）
   (コンスプと)
   (参照解除-等しい (最初の x) (最初の y))
   (参照解除-等しい (残り x) (残り y)))))
「」

最も重要なプリミティブの 1 つは `call` です。
Lisp の `funcall` と同様に、`call` を使用すると目標を構築し、それを証明することができます。

「``lisp」
(defun 呼び出し/1 (目標継続)
  「ゴールを宣言して証明してみてください。」
  (デレフゴール)
  (適用 (述語の作成 (最初の目標)
          (長さ (引数 目標)))
      (append (args goal) (list cont))))
「」

このバージョンの `call` では、最初の要素が適切に定義された述語であるリストに目標がインスタンス化されていない場合、実行時エラーが発生します。これを確認し、定義された述語がない場合は何も表示せずに失敗するようにすると良いでしょう。
目標が正当な場合の `call` の例を次に示します。

「``lisp」
> (?- (= ?p メンバー) (呼び出し (?p ?x (abc))))
?P = メンバー
?X = A;
?P = メンバー
?X = B;
?P = メンバー
?X = C;
いいえ。
「」

`call` ができたので、多くの新しいことを実装できるようになりました。
論理接続詞 and と or は次のとおりです。

「``lisp」
(<- (または ?a ?b) (?a を呼び出す))
(<- (または ?a ?b) (?b を呼び出す))

(<- (そして ?a ?b) (?a を呼び出す) (?b を呼び出す))
「」

これらはバイナリ接続子のみであり、Lisp で使用される *n* 項特殊形式ではないことに注意してください。
また、この定義はコンパイルの利点のほとんどを無効にします。
`and` または `or` 内の目標は、コンパイルされるのではなく、`call` によって解釈されます。

また、「not」、または少なくとも論理的な「not」とはまったく異なる通常の Prolog の「not」を定義することもできます。
実際、いくつかの方言では `not` は `\+` と書かれますが、これは ⊬、つまり「導出できない」という意味になります。
解釈としては、目標 G が証明できない場合は (`not G` ) が真となります。
論理的には、 (`not G` ) が真であることと未知であることの間には違いがありますが、その違いを無視すると、Prolog はより実用的なプログラミング言語になります。
Prologにおける否定の形式意味論の詳細については、[Lloyd 1987](bibliography.md#bb0745)を参照してください。

以下は `not/1` の実装です。
証跡を操作する必要があり、同じことを行う他の述語がある可能性があるため、`maybe-add-undo-bindings` で行われたことをマクロ `with-undo-bindings:` にパッケージ化します。

「``lisp」
(defmacro with-undo-bindings (&body body)
  「最後の式を除くbodyの各式の後のバインディングを元に戻します。」
  (if (長さ=1 body)
      （最初の遺体）
      '(let ((古いトレイル (フィルポインタ *トレイル*)))
         、（最初のbody）
          ,@(ループ for exp in (残りのbody)
                  collect '(undo-bindings! 古いトレイル)
                  経験値を集める))))
(defun not/1 (関係 cont))
  「失敗による否定: G を証明できない場合は (G ではない) が真です。」
  ;; いずれにしても、バインドを解除します。
  (元に戻すバインディング付き
    (call/1 関係 #'(lambda () (return-from not/1 nil)))
    (ファンコールアカウント)))
「」

以下は `not` が正常に動作する例です:

「``lisp」
> (?- (メンバー ?x (abc)) (not (= ?xb)))
?X = A;
?X = C;
いいえ。
「」

ここで、2 つの目標の順序を逆にすると何が起こるかを見てみましょう。

「``lisp」
> (?- (not (= ?xb)) (member ?x (abc)))
いいえ。
「」

最初の例は、`?x` が `b` にバインドされていない限り成功します。
2 番目の例では、`?x` は開始時にバインドされていないため、`(= ?xb )` は成功し、`not` は失敗し、`member` 目標には到達しません。
したがって、`not` の実装には一貫した手続き的解釈がありますが、これは論理否定に通常与えられる宣言的解釈と同等ではありません。
通常、目標の順序に関係なく、`a` と `c` がクエリに対する有効なソリューションになると予想されます。

Prolog と Lisp の基本的な違いの 1 つは、Prolog がリレーショナルであることです。つまり、個々の関係を簡単に表現できます。
一方、Lisp は、物事のコレクションをリストとして表現するのに優れています。
これまでのところ、Prolog で関係を満たすオブジェクトのコレクションを形成する方法はありません。
オブジェクトを反復処理するのは簡単ですが、それらをまとめることはできません。
プリミティブな `bagof` はコレクションを実行する 1 つの方法です。
一般に、`(bagof ?x (p ?x) ?bag)` は、`?bag` を、`(p ?x)` を満たすすべての `?x's` のリストと単一化します。
そのような `?x's` がない場合、 `bagof` の呼び出しは失敗します。
*バッグ* は、重複が許可された順序なしのコレクションです。
たとえば、バッグ {*a*, *b, a*} はバッグ {*a*, *a*, *b*} と同じですが、{*a*, *b*} とは異なります。
バッグは、重複のない順序なしのコレクションである *セット* とは対照的です。
集合 {*a*, *b*} は集合 {*b*, *a*} と同じです。
以下は `bagof` の実装です:

「``lisp」
(defun bagof/3 (exp 目標 結果 継続)
 「GOALに対するすべての解を見つけ、それぞれの解について、
 EXP の値をリスト RESULT に収集します。
 ;; 例: (p 1) (p 2) (p 3) と仮定します。すると次のようになります。
 ;: (bagof ?x (p ?x) ?1) => ?1 = (1 2 3)
 (let ((答えはnil))
 (コール/1 ゴール #'(ラムダ ()
   (push (deref-copy exp) 回答)))
 (if (and (not (null 回答))
  (統一! 結果 (nreverse 回答)))
 (ファンコールアカウント))))
 (defun deref-copy (exp)
 「式をコピーし、変数を新しいものに置き換えます。
 変数のない部分はそのまま返されます。"
 (sublis (mapcar #'(lambda (var) (cons (deref var) (?))
  (どこでもユニーク検索 #'var-p exp))
 exp))
「」

以下では、`bagof` を使用して、Sandy が好きな人のリストを収集します。
結果はセットではなくバッグであることに注意してください。Sandy は複数回表示されます。

「``lisp」
> (?- (bagof ?who (likes Sandy ?who) ?bag))
?WHO = サンディ
?バッグ = (LEE KIM ROBIN SANDY CATS SANDY);
いいえ。
「」

次の例では、`A` と `B` をメンバーとして持つ長さ 3 のすべてのリストのバッグを作成します。

「``lisp」
> (?- (bagof ?l (and (length ?l (1 + (1 + (1 + 0))))
      （そして（メンバーa?l）（メンバーb?l）））
    ？バッグ））
?L = (?5 ?8 ?11 ?68 ?66)
?BAG = ((AB ?17) (A ?21 B) (BA ?31) (?38 AB) (B ?48 A) (?52 BA))
いいえ。
「」

同じ答えの複数のバージョンを含むバッグに失望した人は、`bagof` と同じ計算を行い、重複を破棄するプリミティブ `setof` を好むかもしれません。

「``lisp」
(defun setof/3 (exp 目標 結果 継続)
 「GOALに対するすべての一意の解を見つけ、それぞれの解について、
 EXP の値をリスト RESULT に収集します。
 ;; 例: (p 1) (p 2) (p 3) と仮定します。すると次のようになります。
 ;; (?x (p ?x) ?l の集合) => ?l = (1 2 3)
 (let ((答えはnil))
 (コール/1 ゴール #'(ラムダ ()
   (push (deref-copy exp) 回答)))
 (if (and (not (null 回答))
  (単一化! 結果 (重複を削除
    回答
    :test #'参照が等しい)))
 (ファンコールアカウント))))
「」

Prolog は演算子 `is` を使用した算術演算をサポートしています。
たとえば、`(is ?x (+ ?y 1))` は、`?x` を `?y` の値に 1 を加えた値と単一化します。
この式は、`?y` がバインドされていない場合は失敗し、`?y` が数値でない場合は実行時エラーが発生します。
私たちのバージョンの Prolog では、算術演算だけでなく、あらゆる Lisp 式もサポートできます。

「``lisp」
(defun は /2 (var exp cont)
 ;; 例: (is ?x (+ 3 (* ?y (+ ?z 4))))
 ;; あるいは: (is (?x ?y ?x) (cons (first ?z) ?l))
 (if (and (not (find-if-anywhere #'unbound-var-p exp))
  (unify! var (eval (deref-exp exp))))
 (ファンコールアカウント)))
(defun unbound-var-p (exp)
 「EXP はバインドされていない変数ですか?」
 (そして (var-p exp) (not (bound-p exp))))
「」

余談ですが、Prolog プログラマーに関数 `unbound-var-p` へのアクセス権を与えてもよいでしょう。
この述語の標準名は `var/1` です。

「``lisp」
(無効な var/1(?arg1 cont)
  「?arg1 がインスタンス化されていない変数の場合に成功します。」
  (if (unbound-var-p ?arg1)
  (ファンコールアカウント)))
「」

2 番目の引数の一部がバインドされていない場合、 is プリミティブは失敗します。
ただし、`eval` を直接呼び出すことはできないものの、解決できる変数を含む式があります。
たとえば、次の目標は、`?x` を `2` にバインドすることで解決できます。

「``lisp」
((= 12 (* (+ ?x 1) 4))を解く)
「」

Prolog から Lisp にもっと直接アクセスしたいと思うかもしれません。
`is` の問題は、バインドされていない変数のチェックが必要であり、引数を再帰的に評価するために `eval` を呼び出すことです。
場合によっては、is が提供するセーフティ ネットを経由せずに、Lisp の `apply` だけを実行したいことがあります。
プリミティブな `lisp` がそれを行います。
言うまでもなく、`lisp` は標準 Prolog の一部ではありません。

「``lisp」
(defun lisp/2 (?結果 exp cont)
 「(最初の exp) を (残りの exp) に適用し、結果を返します。」
 (if (and (consp (deref exp))
  (unify! ?result (apply (最初の式) (残りの式))))
 (ファンコールアカウント)))
「」

**演習12.7 [m]** 学生の演習で使用した関数 `solve` と同じように動作するプリミティブ `solve/1` を定義します ([ページ 225](chapter7.md#p225))。
引数として単一の方程式を取るか、方程式のリストを取るかを決定します。

**演習 12.8 [h]** `(solve (= 12 (* (+ ?x 1) 4)))` という形式の目標があると仮定します。
実行時に `solve/1` が呼び出されたときに方程式を操作するのではなく、呼び出しを `(solve (= ?x 2))` であるかのように扱い、コンパイル時に作業の一部を実行することを好む場合があります。
`solve` 用の Prolog コンパイラ マクロを記述します。
コンパイラ マクロを定義した場合でも、述語が `call/1` を通じて呼び出される可能性があるため、基礎となるプリミティブが必要であることに注意してください。
Lisp でも同じことが起こります。コンパイラ マクロを提供する場合でも、`funcall` または `apply` の場合は実際の関数が必要になります。

**演習 12.9 [h]** 述語 `call`、`and`、`or`、`not`、`repeat` のうち、コンパイラ マクロの恩恵を受けられるのはどれですか。
使用できる述語に対してコンパイラ マクロを記述します。

**演習 12.10 [m]** `call/1` が 2 つの重要な点で非効率的であることに気づいたかもしれません。
まず、`make-predicate` を呼び出します。これは、文字列を追加してシンボルを構築し、その文字列を Lisp シンボル テーブルで検索する必要があります。
`make-predicate` を変更して、述語シンボルが最初に作成されたときにそれを保存し、後続の呼び出しでより高速に検索できるようにします。
2 番目の非効率性は、append の呼び出しです。
継続引数が最後ではなく最初に来るようにコンパイラ全体を変更し、`call` で追加する必要がなくなります。

**演習 12.11 [s]** プリミティブ `true/0` は常に成功し、 `fail/0` は常に失敗します。
これらのプリミティブを定義します。
ヒント: 最初のものは Common Lisp 関数に対応し、2 番目はこの章ですでに定義されている関数です。

**演習 12.12 [s]** `==/2` をプリミティブではなく節のリストとして記述することは可能でしょうか?

**演習 12.13 [m]** 引数式を 1 回だけ走査する `deref-copy` のバージョンを記述します。

## 12.9 カット

Lisp では、バックトラックポイントが 1 つまたは 2 つ以上ある場合は扱いにくいものの、明示的にバックトラックするプログラムを記述できます。
Prolog では、バックトラックは自動的かつ暗黙的に行われますが、バックトラックを回避する方法はまだわかっていません。
Prolog プログラマがバックトラックを無効にしたい理由は 2 つあります。
まず、バックトラックポイントを追跡するには時間とスペースが必要です。
ある問題には 1 つの解決策しかないことを知っているプログラマーは、プログラムに他の可能な分岐を考慮しないように指示することで計算を高速化できるはずです。
第二に、問題を単純に論理的に指定すると、冗長な解決策や、意図しない解決策が生成されることがあります。
単に検索空間を整理してバックトラッキングをなくすと、必要な答えだけが得られるかもしれませんが、すべての答えと正しい答えだけが得られるようにプログラムを再構築するのはより困難でしょう。
ここに例があります。
3 番目の引数が最初の 2 つの引数の最大値である場合に成立する述語 `max/3` を定義したいとします。ここで、最初の 2 つの引数は常に数値にインスタンス化されます。
簡単な定義は次のとおりです。

「``lisp」
(<- (最大 ?x ?y ?x) (>= ?x ?y))
(<- (最大 ?x ?y ?y) (< ?x ?y))
「」

宣言的にはこれは正しいのですが、手続き的には、`>=` が成功した場合に `<` 関係を計算するのは時間の無駄です。その場合、`<` は決して成功しません。
`!` と書かれたカット記号を使用すると、無駄な計算を停止できます。
次のように書くこともできます。

「``lisp」
(<- (最大 ?x ?y ?x) (>= ?x ?y) !)
(<- (最大 ?x ?y ?y))
「」

最初の節のカットは、最初の節が成功した場合、他の節は考慮されないことを示しています。
したがって、2 番目の条項は単独では解釈できません。
むしろ、これは「最初の節が失敗した場合、2 つの数値の `max` は 2 番目の数値になる」と解釈されます。

一般的に、カットは節の最後だけでなく、節bodyのどこにでも発生する可能性があります。
カットについては適切な宣言的解釈はありませんが、手続き的解釈は 2 つあります。
まず、カットが目標として「実行」されると、それは必ず成功します。
しかし、成功するだけでなく、後戻りしても越えられない柵も設置されます。
カットは、カットの右側の目標 (同じ節内) とカットの下の節 (同じ述語内) の両方からのバックトラッキングを遮断する役割を果たします。
より抽象的な例を見てみましょう。

「``lisp」
(<- (p) (q) (r) ! (s) (t))
(<- (p) (s))
「」

`p` の最初の節を処理する際、`q` と `r` を解決しようとしている間にバックトラックが自由に発生する可能性があります。
`r` が解決されると、カットが赤に遭遇します。
その時点から、`s` と `t` を解決しながらバックトラックが自由に発生する可能性がありますが、Prolog はカットを超えて `r` にバックトラックすることはなく、2 番目の節も考慮されません。
一方、`q` または `r` が失敗した場合 (カットに遭遇する前)、Prolog は 2 番目の節に進みます。

カットの意図が明確になったので、それをどのように実装するかを考えてみましょう。
変数と複数のカットを含む、もう少し複雑な述語を見てみましょう。

「``lisp」
(<- (p ?xa) ! (q ?x))
(<- (p ?xb) (r ?x) ! (s ?x))
「」

カットに戻るとすぐに、それ以上の目標は考慮されないように調整する必要があります。
最初の節では、`q/1` が失敗した場合、2 番目の節を考慮せずに、すぐに `p/2` から戻りたいと考えています。
同様に、`s/1` が初めて失敗したときは、`r/1` の他の解決策を検討するのではなく、`p/2` から戻りたいと考えます。
したがって、次のようなコードが必要になります。

「``lisp」
(デッド p/2 (argl arg2 count)
 (let ((古いトレイル (フィルポインタ *トレイル*)))
  (if (unify! arg2 'a)
   (progn (q/1 argl cont)
     (p/2 nil からの戻り)))
  (バインドを解除! 古いトレイル)
  (if (unify! arg2 'b)
   (r/1 argl #'(lambda ()
       (progn (s/1 argl cont)
        (戻り値 p/2 nil)))))))
「」

このコードは、`compile-body` に 1 つの変更を加えることで取得できます。bodyの最初のゴール (またはbodyの残りの部分) がカット シンボルである場合、残りのbodyのコードを含む `progn` を生成し、その後にコンパイルされる述語の `return-from` を生成しなければなりません。
残念ながら、述語の名前は `compile-body` では使用できません。
`compile-clause` と `compile-body` を変更して述語名を追加の引数として受け取るようにしたり、述語を `compile-predicate` 内の特殊変数としてバインドしたりすることができます。
私は後者を選びます:

「``lisp」
(defvar *述語* nil
  「現在コンパイル中の Prolog 述語」

(defun compile-predicate (シンボル arity 節)
  「指定されたシンボル/アリティのすべての節をコンパイルする
  単一の LISP 関数に変換します。"
  (let ((*述語* (述語作成シンボルのアリティ)) ;***
        (パラメータ (make-parameters arity)))
    （コンパイル
     (評価
      `(defun ,*述語* (,@パラメータ続き)
  .,(多分、元に戻すバインディングを追加
     (mapcar #'(lambda (節)
           (コンパイル節パラメータ節 'cont))
      節)))))))

(defun compile-body (body cont バインディング)
  「節のbodyをコンパイルします。」
  （条件
    ((本文なし)
     `(ファンコール、アカウント))
    ((eq (最初のbody) '!) ;***
     `(progn ,(compile-body (rest body) cont bindings) ;***
             (戻り値、*述語* nil))) ;***
    (t (let* ((目標 (最初のbody))
              (マクロ (プロローグコンパイラマクロ (述語目標)))
              (マクロ値 (マクロの場合
                             (funcallマクロ目標(残りのbody)
                                      contバインディング))))
        (if (and マクロ (not (eq マクロ値 :pass)))
            マクロ値
            `(,(make-predicate (述語目標)
                               （関係性目標）
              ,@(mapcar #'(lambda (arg)
                            (コンパイル引数 引数バインディング))
                        (引数の目標))
              ,(if (null (残りのbody))
                   続き
                   `#'(ラムダ()
                        、(コンパイルbody
                           （残りの本文）続き
                           (bind-new-variables バインディング ゴール))))))))))
「」

**演習 12.14 [m]** 以下の定義に基づいて、`test-cut` の呼び出しが何を実行し、何が書き込まれるかを考えます。

「``lisp」
(<- (テストカット) (pa) (pb) ! (pc) (pd))
(<- (テストカット) (pe))
(<- (p ?x) ((?x 1) と書く))
(<- (p ?x) ((?x 2) と書く))
「」

カットを使用する別の方法は、*繰り返し/失敗*ループです。
述語 `repeat` は次の 2 つの節で定義されます。

「``lisp」
(<- (繰り返し))
(<- (繰り返し) (繰り返し))
「」

プリミティブとしての別の定義は次のとおりです。

「``lisp」
(defun 繰り返し/0 (継続)
  (ループ (funcall cont)))
「」

残念ながら、「repeat」は最も乱用される述語の 1 つです。
いくつかの Prolog の本では、次のようなプログラムが紹介されています。

「``lisp」
(<- (メイン)
  （「こんにちは」と書いてください）
  （繰り返す）
  （「コマンド：」と入力してください）
  (読み取り?コマンド)
  (プロセス?コマンド)
  (= ?コマンド終了)
  （「さようなら」と書いてください。）
「」

目的は、コマンドを 1 つずつ読み取って処理することです。
`exit` 以外の各コマンドに対して、`process` は適切なアクションを実行してから失敗します。
これにより、繰り返し目標までバックトラックされ、新しいコマンドが読み取られて処理されます。
コマンドが `exit` の場合、プロシージャは戻ります。

このプログラムが不十分な理由は 2 つあります。
まず、参照透明性の原則に違反します。
似ているものは、使用される文脈に関係なく、似ているはずです。
しかし、ここでは、bodyの 6 つの目標のうち 4 つがループを構成し、残りの目標がループの外側にあることを知る方法はありません。
第二に、それは抽象化の原則に違反します。
述語は個別の単位として理解できる必要があります。
しかし、ここで述語プロセスを理解するには、それが呼び出されるコンテキスト、つまり各コマンドの処理後に失敗することを要求するコンテキストを考慮する必要があります。
[Richard O'Keefe 1990](bibliography.md#bb0925)が指摘しているように、この節の正しい書き方は次のとおりです。

「``lisp」
(<- (メイン)
  （「こんにちは」と書いてください）
  （繰り返す）
      （「コマンド：」と入力してください）
      (読み取り?コマンド)
      (プロセス?コマンド)
      （または（= ?コマンド終了）（失敗））
  ！
  （「さようなら」と書いてください。）
「」

インデントにより、繰り返しループの制限が明確に示されます。
ループは明示的なテストによって終了され、その後にカットが続くため、呼び出し元のプログラムは、終了した後に誤ってループに戻ることはありません。
個人的には、括弧によってループなどの構造が明示的になり、インデントが自動的に行われる Lisp のような言語を好みます。
しかし、オキーフは、よく構造化された読みやすいプログラムを Prolog で記述できることを示しています。

if-then および if-then-else 構文は、節として簡単に記述できます。
if-then-else は、テストが満たされた場合にカットを使用して `then` 部分にコミットすることに注意してください。

「``lisp」
(<- (if ?test ?then) (if ?then ?else (fail)))
(<- (if ?test ?then ?else)
  (?test を呼び出す)
  ！
  （電話して？）
(<- (if ?test ?then ?else)
  (呼び出し?else))
「」

カットは非論理的な「not」を実装するために使用できます。
`not` の定義として、次の 2 つの節がよく使用されます。
私たちのコンパイラは、これらの 2 つの節を、プリミティブ `not/1` に対して以前に与えられたものとまったく同じコードに変換します。

「``lisp」
(<- (?p ではない) (?p を呼び出す) ! (失敗))
(<- (?p ではない))
「」

## 12.10 「実際の」プロローグ

この章で開発される Prolog-In-Lisp システムは、Lisp システムに組み込むことを目的としているため、Lisp 構文を使用します。
Lisp 構文を使用する他の Prolog 実装には、micro-Prolog、Symbolics Prolog、LMI Prolog などがあります。

ただし、Prolog システムの大部分は、従来の数学表記に近い構文を使用します。
次の表は、「標準」Prolog の構文と Prolog-In-Lisp の構文を比較したものです。
現在、Prolog の標準化に取り組んでいる国際委員会がありますが、最終報告書はまだ発表されていないため、方言によって構文が若干異なる場合があります。
ただし、ほとんどの実装はここで要約した表記法に従います。
これらは、エディンバラ大学の David H. が DEC-10 用に開発した Prolog から派生したものです。
D.
ウォーレンと彼の同僚たち。
最後のセクションのプリミティブの名前も、Edinburgh Prolog から取られています。

| | Prolog | Prolog-In-Lisp |
|----------|------|---------- ----|
| アトム | `lower` | `const` |
|変数 | '上' | `?だった` |
| 匿名 | `-` | `?` |
|空白 | `p(Var,const)` | `(p ?var const)` |
| ルール | `p(X) :- q(X).` | `(<- (p ?x) (q ?x))` |
| 事実 | `p(a).` | `(<- (pa))` |
| クエリ | `?- p(X).` | `(?- (p ?x))` |
| リスト | `[a,b,c]` | `(abc)` |
| cons | `[a| Rest]` | `(a . ?rest)` |
| nil | `[]` | `()` |
| および | `p(X). q(X)` | `(および (p ?x) (q ?x)>` |
| または | `P(X): q(X)` | `(または (p ?x) (q ?x))` |
| ではない | `\+ p(X)` | `(not (p ?x))` |

私たちは Lisp のリスト重視の考え方を採用しました。つまり、項はアトム、変数、および他の項のコンスから構築されます。
実際の Prolog ではコンス セルが提供されますが、項は通常リストではなく *構造* から構築されます。
Prolog の項 `p(a,b)` は、リスト `(pab)` ではなく、Lisp ベクトル `#(p/2 ab)` に対応します。
Prolog 実装の少数では *構造共有* を使用します。このアプローチでは、すべての非アトミック項は、変数のプレースホルダーを含むスケルトンと、スケルトンを指し、プレースホルダーを埋める変数も含むヘッダーによって表されます。
構造共有を使用すると、コピーの作成は簡単です。スケルトンのサイズに関係なく、ヘッダーをコピーするだけです。
ただし、用語の操作は、スケルトンとヘッダーの両方を追跡する必要があるため複雑になります。
構造共有の詳細については[Boyer and Moore 1972](bibliography.md#bb0110)を参照してください。

もう 1 つの大きな違いは、実際の Prolog では成功継続ではなく失敗継続と同等のものが使用されることです。
クロージャという意味での実際の継続は構築されません。
代わりに、選択が行われると、次の選択のコード アドレスがスタックにプッシュされます。
失敗すると、次の選択肢がスタックからポップされます。
これは、[ページ 772](chapter22.md#p772) で概説されている Scheme の `call/cc` 機能を使用したバックトラッキング アプローチを彷彿とさせます。

**演習 12.15 [m]** 成功継続の代わりに失敗継続のスタックを使用するアプローチを想定して、`p` と `member` のコードがどのようになるかを示します。
失敗の継続を渡す必要がないことに注意してください。`top-level-prove` が呼び出すスタックにプッシュするだけで済みます。
削減はどのように実施されるのでしょうか?
成功継続を使用してコンパイラを実装するという正しい選択をしたのでしょうか、それとも失敗継続の方がよかったのでしょうか?

## 12.11 歴史と参考文献

[第 11 章](chapter11.md) で説明したように、論理プログラミングの考え方は 1970 年代半ばまでにかなりよく理解されていました。
しかし、当時の実装は遅かったため、論理プログラミングは普及しませんでした。
論理プログラミングを Lisp やその他の汎用言語に代わる本格的な選択肢にしたのは、DEC-10 用の Prolog コンパイラでした。
このコンパイラは 1977 年に David H. によって開発されました。
D.
ウォーレンとフェルナンド・ペレイラ、ルイス・ペレイラ。
[Warren (1979)](bibliography.md#bb1325) および 3 名全員 (1977) による論文を参照してください。

残念ながら、David H.
D.
ウォーレンの Prolog コンパイルに関する先駆的な研究は、これまで広くアクセス可能な形で公開されたことはありません。
彼の主な貢献は、コンパイルされた Prolog の命令セットである Warren Abstract Machine (WAM) の説明でした。
既存のコンパイラのほとんどは、この命令セット、またはそれに若干の修正を加えたものを使用します。
これは、バイトコードの解釈またはネイティブマシン命令へのマクロ展開を通じて実行できます。
[Aït-Kaci 1991](bibliography.md#bb0020)はWAMに関する優れたチュートリアルを提供しているが、オリジナル([Warren 1983](bibliography.md#bb1330))よりもはるかに簡潔である。
この章で紹介するコンパイラは WAM を使用しません。
代わりに、これは Mark [Stickel (1988)](bibliography.md#bb1200) の定理証明器をモデルにしています。
同様のコンパイラは、Jacques [Cohen 1985](bibliography.md#bb0225)によって簡単に説明されています。

## 12.12 演習

**演習 12.16 [m]** 暗黙の `calls` を許可するように Prolog コンパイラを変更します。
つまり、目標が述語で始まるコンス セルでない場合は、それを `call` であるかのようにコンパイルします。
条項:

「``lisp」
(<- (p ?x ?y) (?xc) ?y)
「」

次のようにコンパイルする必要があります:

「``lisp」
(<- (p ?x ?y) ((?xc) を呼び出す) (?y を呼び出す))
「」

**演習 12.17 [h]** 以下に、いくつかの標準的な Prolog プリミティブを示します。

* `get/1` 1文字を読み取り、引数と単一化します。

* `put/1` 1文字を出力します。

* `nonvar/1, /=, /==` はそれぞれ `var, = および = =` の反対です。

* `integer/1` 引数が整数の場合は True になります。

* `atom/1` 引数がシンボル（Lisp の `symbol p` など）の場合は True になります。

* `atomic/1` 引数が数値またはシンボル（Lisp の `atom` など）の場合は True になります。

* `<`、`>`、`=<`、`>=` 算術比較。引数が両方とも数値にインスタンス化され、比較が真の場合に成功します。

* `listing/0` 定義されたすべての述語の節を出力します。

* `listing/1` 引数述語の節を出力します。

これらの述語を実装します。
それぞれのケースで、述語をプリミティブとして実装するか、節のリストとして実装するか、およびコンパイラ マクロを使用するかどうかを決定します。

解決する必要がある名前の競合がいくつかあります。
「atom」のような用語は、Prolog ではある意味を持ち、Lisp では別の意味を持ちます。
また、Prolog での通常の表記は `/=` と `/==` ではなく `\=` と `\==` です。
Prolog-In-Lisp の場合、Prolog と Lisp のどちらの表記法を使用するかを決定する必要があります。

**演習 12.18 [s]** Lispでは、`(< 1 n 10 )`や`(= xyz)`のようなn項呼び出しを書くことに慣れています。
n 項呼び出しを一連の 2 項呼び出しに展開するコンパイラ マクロを記述します。
たとえば、`(< 1 n 10)` は `(and (< 1 n) (< n 10))` に展開されます。

**演習 12.19 [m]** Prolog にはない Lisp の機能の 1 つは、`quote` メカニズムです。
`quote` には用途がありますか? ある場合は実装してください。ない場合は、なぜ必要ないのか説明してください。

**演習 12.20 [h]** Prolog のトレース機構を記述します。
Prolog 述語をトレースおよびトレース解除するための手順 `p-trace` および `p-untrace` を追加します。
トレースされた目標の印刷プロシージャへの呼び出しを生成するコードをコンパイラに追加します。
Lisp では、プロシージャが呼び出されたときと戻ったときを追跡する必要があります。
Prolog では、呼び出し、正常完了、後続の節へのバックトラック、およびそれ以上の節がない失敗という 4 つのケースを考慮する必要があります。
これら 4 つのケースをそれぞれ `call`、`exit`、`redo`、`fail` と呼びます。
`member` をトレースすると、トレース出力は次のようになると予想されます。

「``lisp」
> (?- (メンバー ?x (abcd)) (失敗))
  コールメンバー: ?1 (ABCD)
  退場メンバー: A (ABCD)
  やり直しメンバー: ?1 (ABCD)
    コールメンバー: ?1 (BCD)
    退場メンバー: B (BCD)
    やり直しメンバー: ?1 (BCD)
      コールメンバー: ?1 (CD)
      退場メンバー: C (CD)
      REDOメンバー:?1 (CD)
        コールメンバー: ?1 (D)
        退会メンバー: D (D)
        やり直しメンバー: ?1 (D)
          コールメンバー: ?1 NIL
          やり直しメンバー: ?1 NIL
          不合格メンバー: ?1 NIL
        不合格メンバー: ?1 (D)
      不合格メンバー: ?1 (CD)
    不合格メンバー: ?1 (BCD)
  不合格メンバー: ?1 (ABCD)
いいえ。
「」

**演習 12.21 [m]** 一部の Lisp システムでは関数のコンパイルが非常に遅くなります。
`KCL` は例です。`C` に変換してから `C` コンパイラとアセンブラを呼び出してコンパイルします。
`KCL` では、完全にデバッグされたコードのみをコンパイルし、プログラムの開発中に解釈されて実行するのが最適です。

Lisp コンパイラの呼び出しがオプションになるように Prolog コンパイラを変更します。
いずれの場合も、Prolog 関数は Lisp に変換されますが、変数が設定されている場合にのみマシン語にコンパイルされます。

**演習 12.22 [d]** 一部の Prolog システムでは、変数がインスタンス化されるまで目標を「凍結」する述語 `freeze` が提供されています。
たとえば、目標 `(freeze x (> x 0))` は次のように解釈されます: `x` がインスタンス化されると、目標 `(> x 0)` を評価し、結果に応じて成功または失敗します。
ただし、`x` がバインドされていない場合は成功して計算を続行しますが、目標 `(> x 0)` を記憶し、`x` がインスタンス化されるとすぐにそれを評価します。
`freeze` を実装します。

**演習 12.23 [m]** ローカル関数を使用しない `anonymous-variables-in` の再帰バージョンを記述します。

## 12.13 回答

**回答 12.6** Texas Instruments および Lucid 実装で動作するバージョンは次のとおりです。

「``lisp」
(defmacro with-compilation-unit (options &body body)
  「bodyを実行しますが、コンパイラの警告は最後まで遅延します。」
  ;; これは Common Lisp the Language, 2nd ed. で定義されています。
  '(,(読み取り時ケース
    #+TI 'コンパイラ:コンパイラ警告コンテキストバインド
    #+Lucid '遅延警告付き
        'プロン)
    。、体））

(defun prolog-compile-symbols (&optional (シンボル *未コンパイル*))
  「Prolog シンボルのリストをコンパイルします。
  デフォルトでは、必要なすべてのシンボルがリストに表示されます。"
  (コンパイル単位()付き)
  (マップ #'prolog-compile シンボル)
  (setf *未コンパイル* (set-difference *未コンパイル* シンボル))))
「」

**回答 12.9** `and` および `or` のマクロはよく使用されるため、非常に重要です。
`and` のマクロは簡単です:

「``lisp」
(def-prolog-compiler-macro と (目標body cont バインディング))
  (compile-body (append (args goal) body) cont バインディング))
「」

`or` のマクロはより複雑です:

「``lisp」
(def-prolog-compiler-macro または (目標body cont バインディング))
  (let ((disjuncts (args goal)))
    (case (長さの論理和)
      (0 失敗)
      (1 (コンパイルbody (cons (最初の論理和) body) cont バインディング))
      (t (let ((fn (gensym "F")))
        '(flet ((,fn () ,(compile-body body cont バインディング)))
          .,(多分、元に戻すバインディングを追加
            （選言のgをループして収集する
              (コンパイルbody (リスト g) '#',fn
                バインディング)))))))))
「」

**回答 12.11** `true/0` は `funcall` です。目標が成功すると継続を呼び出し、 `fail/0` は `ignore` です。目標が失敗すると継続を無視します。
これらのプリミティブに対してコンパイラ マクロを定義することもできます。

「``lisp」
(def-prolog-compiler-macro true (目標bodycontバインディング)
  (compile-body bodyのバインディング))

(def-prolog-compiler-macro 失敗 (目標bodyのバインディングが続く))
  (宣言 (目標bodyの継続バインディングを無視))
  なし
「」

**回答12.13**

「``lisp」
(defun deref-copy (exp)
  「変数を含む可能性のある式のコピーを作成します。
  変数のない部分はそのまま返されます。"
  (let ((var-alist nil ))
    （ラベル
      ((歩く (exp)
        (deref exp)
        (条件 ((consp exp)
          (reuse-cons (walk (最初のexp))
              (歩く (休憩経験))
              exp))
          ((var-p exp)
          (let ((エントリ (連想 exp 変数-連想リスト)))
            (if (not (null エントリ))
            (cdr エントリ)
            (let ((var-copy (?)))
                (push (cons exp var-copy) var-alist)
                var-コピー))))
          (t exp))))
    (ウォーク経験))))
「」

**回答 12.14** `test-cut` の最初の節では、`p` への 4 つの呼び出しはすべて `p` の最初の節を介して成功します。
次に、`(pc)` と `(pd)` の呼び出しでバックトラックが発生します。
`1` と `2` の 4 つの組み合わせはすべて成功します。
その後、バックトラックは通常、`(pb)` の呼び出しに戻ります。
しかし、カットによってこれが阻止され、2 番目の節が考慮されることなく、`(test-cut)` 目標全体が失敗します。
実際の出力は次のとおりです。

「``lisp」
(?- (テストカット))
(A 1)(B 1)(C 1)(D 1)
はい;
（D2）
はい;
(C 2)(D 1)
はい;
（D2）
はい;
いいえ。
「」

**回答12.17** たとえば:

「``lisp」
(defun >/2 (xy 継続)
  (if (そして (numberp (deref x)) (numberp (deref y)) (> xy))
    (ファンコールアカウント)))
(defun numberp/1 (x 継続)
  (if (numberp (deref x))
    (ファンコールアカウント)))
「」

**回答 12.19** Lisp では、`quote` を 2 つの方法で使用します。シンボルとそのシンボルによって表される変数の値を区別するため、およびリテラル リストと関数呼び出しを評価することによって返される値を区別するためです。
Prolog が語彙規則によって行う最初の区別: 変数は Prolog では疑問符で始まり、実際の Prolog では大文字で始まります。
Prolog は関数型ではなくリレーショナル型であるため、2 番目の区別は必要ありません。
式は、節のbodyのメンバーである場合は目標であり、目標への引数である場合はリテラルです。

**回答 12.20** ヒント: `member` に、4 種類のトレース イベントに関する情報を出力するプロシージャ `prolog-trace` の呼び出しを追加する方法は次のとおりです。

「``lisp」
(消滅したメンバー/2(?arg1?arg2 cont)
 (let ((古いトレイル (フィルポインタ *tra1l*))
   (終了-継続 #'(ラムダ()
     (プロローグ トレース 'exit 'メンバー ?arg1 ?arg2 )
     (ファンコールアカウント))))
  (プロローグ トレース 'call 'メンバー ?arg1 ?arg2)
  (if (unify! ?arg2 (cons ?arg1 (?)))
   (funcall exit-cont))
  (バインドを解除! 古いトレイル)
  (プロローグ トレース 'redo 'メンバー ?arg1 ?arg2)
  ((?休ませてください (?)))
   (if (unify! ?arg2 (cons (?) ?rest))
   (メンバー/2 ?arg1 ?rest exit-cont)))
  (プロローグ トレース 'fail' メンバー ?arg1 ?arg2)))
「」

`prolog-trace` の定義は次のとおりです。

「``lisp」
(defvar *プロローグ トレース インデント* 0)
(defun prolog-trace (種類述語 &残り引数)
  (if (メンバーの種類 '(やり直しの呼び出し))
  (incf *プロローグ トレース インデント* 3))
  (フォーマット t "~&~VT~a ~ a:~{ ~ a ~}"
      *prolog-trace-indent* 種類述語引数)
  (if (メンバーの種類 '(失敗終了))
  (def *プロローグ トレース インデント* 3)))
「」

**答え 12.23**

「``lisp」
(匿名変数を定義 (ツリー)
  「ツリー内で一度だけ出現するすべての変数のリストを返します。」
  (値 (匿名変数ツリー nil nil)))

(匿名変数の定義 (ツリーが一度見られ、さらに見られる))
  「データ構造TREEをたどり、変数のリストを返す
  一度だけ表示される変数のリストと、複数回表示される変数のリストです。」
  （条件
    ((consp ツリー)
    (複数値バインド (一度だけ新しいもの、さらに新しいもの))
      (anon-vars-in (最初の木) 一度見た後、もう一度見た)
      (anon-vars-in (rest tree) new-seen-once new-seen-more)))
    ((not (変数-p ツリー)) (値が 1 回以上表示された))
    ((メンバーツリーは一度だけ表示されます)
    (値 (ツリーを一度だけ削除) (コンス ツリーをもう一度)))
    ((メンバーツリー表示-詳細)
    (一度見た値、もう一度見た値)
    (t (値 (コンスツリーは1回だけ表示)、さらに1回表示))))
「」
